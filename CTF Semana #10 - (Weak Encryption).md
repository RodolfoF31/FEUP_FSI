# CTF Semana #10 - (Weak Encryption)

In this CTF, we received a Python script featuring functions for encrypting, decrypting, and generating keys for AES-128-CTR encryption. While the encryption and decryption functions performed flawlessly, a critical error was identified in the key generation process. At the outset of the CTF, the challenge involved connecting to a remote server to retrieve the hexadecimal message and nonce. This information was crucial for decrypting the message, which happened to be the flag in our case. The provided flag and nonce were:

```python
hex_ciphertext = "a76ed74a517098ecc43be7b7eb35676b8293fedf2b3eed2f5bbe3c96b532104e3a87baead44464"
hex_nonce = "d07e98615f97617a1d3cb129298c0427"
```
The first thing we did after obtaining this was to tranform this into binary format, the format that the encrypt and decrypt function expect using unhexify:

```python
import binascii
ciphertext = binascii.unhexlify(hex_ciphertext)
nonce = binascii.unhexlify(hex_nonce)
```

Upon obtaining two byte sequences, the only barrier to revealing the flag was the encryption key. However, a flaw in the 'gen' function became apparent that was setting the first 13 bytes of the 16-byte key to 0, reducing potential permutations to 16,777,216. This flaw facilitated a successful brute force attack. The attack, leveraging the 'gen' function, iteratively generated new keys and attempted decryption. If a key had been used, the attack moved on. It concluded upon discovering the correct key, which, in this instance, was the word 'flag'. With the otimization of not repeting key the result was obtained in 1 minute instead of 5 minutes.



Code user:
```python
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
import binascii
import os

KEYLEN = 16

def gen(): 
	offset = 3 # Hotfix to make Crypto blazing fast!!
	key = bytearray(b'\x00'*(KEYLEN-offset)) 
	key.extend(os.urandom(offset))
	return bytes(key)

def enc(k, m, nonce):
	cipher = Cipher(algorithms.AES(k), modes.CTR(nonce))
	encryptor = cipher.encryptor()
	cph = b""
	cph += encryptor.update(m)
	cph += encryptor.finalize()
	return cph

def dec(k, c, nonce):
	cipher = Cipher(algorithms.AES(k), modes.CTR(nonce))
	decryptor = cipher.decryptor()
	msg = b""
	msg += decryptor.update(c)
	msg += decryptor.finalize()
	return msg


hex_ciphertext = "a76ed74a517098ecc43be7b7eb35676b8293fedf2b3eed2f5bbe3c96b532104e3a87baead44464"
hex_nonce = "d07e98615f97617a1d3cb129298c0427"

ciphertext = binascii.unhexlify(hex_ciphertext)
nonce = binascii.unhexlify(hex_nonce)

flag_set = {b""}
decrypted_message = b""

while True:
	key = gen()
	if key in flag_set:
		continue

	flag_set.add(key)
	decrypted_message = dec(key, ciphertext, nonce)
	string_message = decrypted_message.decode('latin-1')

	if "flag" in string_message:
		print(f"Key: {key} || Message: {string_message}")
		break
```

Output obtained:
<img src="/images/flag_decrypt.png" alt="Flag decrypted">


## How can I use this cipher suite to encrypt and decrypt data?
The script includes a Cipher object that takes encryption algorithm and mode as parameters, featuring the functions `encryptor()` and `decryptor()`.

## How can I take advantage of the vulnerability I observed to break the code?
As mentioned earlier, the key's limitation to 3 randomly generated bytes, with the remainder padded with zeros, significantly reduces the number of possibilities, making brute force attacks relatively straightforward.

## How can I automate this process so that my attack knows it has found the flag?
We can efficiently employ the 'gen' function in a while loop, halting the iteration once the word 'flag' is found. This, of course, comes after decoding the byte message.
